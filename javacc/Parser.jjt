options {

  LOOKAHEAD = 1;

}


PARSER_BEGIN(Parser)

public class Parser{

   public static void main(String args[]) throws ParseException {

   }

}

PARSER_END(Parser)


//characters to ignore/skip
SKIP: {
    " " 
  | "\r" 
  | "\t" 
  | "\n" 
  | <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> 
}

TOKEN: {

    < INTEGER : (["0" - "9"])+ >
	| < INT: "int" >
	| < BOOLEAN: "boolean" >
	| < STRING: "string" >
	| < SEMICOLON: ";" >
	| < COLON: "," >
	| < DOT: "." >
	| < TRUE: "true" >
	| < FALSE: "false" >
	| < NEW: "new" >
	| < THIS: "this" >
	| < LBRACKET: "{" >
	| < RBRACKET: "}" >
	| < LSQUAREBRACKET: "[" >
	| < RSQUAREBRACKET: "]" >
	| < LPAR: "(" >
	| < RPAR: ")" >
	| < PUBLIC: "public" >
	| < STATIC: "static" >
	| < VOID: "void" >
	| < MAIN: "main" >
	| < RETURN: "return" >
	| < EXTENDS: "extends" >
	| < IMPORT: "import" >
	| < CLASS: "class" >
	| < WHILE: "while" >
	| < IF: "if" >
	| < ELSE: "else" >
	| < EQUAL: "=" >
	| < ADD: "+" >
	| < SUB: "-" >
	| < MUL: "*" >
	| < DIV: "/" >
	| < NOT: "!" >
	| < MINOR: "<" >
	| < AND: "&&" >
	| < LENGTH: "length" >
	| < STRINGARRAY: "String[]" >
	| < IDENTIFIER: ["a"-"z", "A"-"Z"](["_", "a"-"z", "A"-"Z", "0"-"9"])* >
}


//DECLARATIONS

void Program() : {}
{
  ImportDeclaration() ClassDeclaration() <EOF>
}


//Implemented following teachers examples (Lazysort.jmm)

void ImportDeclaration() : {}
{
  (
    
    <IMPORT> (<STATIC>)? <IDENTIFIER>
    (AuxImport())?
    (Type())?
    <SEMICOLON>
  
  )*
}

void AuxImport():{}
{
  <DOT> <IDENTIFIER> <LPAR> Type() (<COLON> Type())* <RPAR>
}

void ClassDeclaration() : {}
{
  <CLASS> <IDENTIFIER> 
  (<EXTENDS> <IDENTIFIER>)?
  <LBRACKET>
    (VarDeclaration())*
    (MethodDeclaration())*
  <RBRACKET>
}

void VarDeclaration() : {}
{
  Type() <IDENTIFIER> <SEMICOLON>
}


void MethodDeclaration() : {}
{ // <a> (<b> | <c>)

  <PUBLIC> (
    Type() <IDENTIFIER> <LPAR> ( Type() <IDENTIFIER> ( <COLON> Type() <IDENTIFIER> )* )? <RPAR> <LBRACKET>
    (LOOKAHEAD(2) VarDeclaration())*
    (Statement())*
    <RETURN> Expression() <SEMICOLON>
    | <STATIC> <VOID> <MAIN> <LPAR> ( <STRINGARRAY> <IDENTIFIER> )?<RPAR> <LBRACKET>
    (LOOKAHEAD(2) VarDeclaration())*
    (Statement())*)
  <RBRACKET>

}
 
void Type(): {}
{
  	<INTEGER> (<LSQUAREBRACKET> <RSQUAREBRACKET>)? //int or int[]
  	| <BOOLEAN>
  	| <IDENTIFIER>
}

void Statement(): {}
{
	<LBRACKET> (Statement())* <RBRACKET>
	| <IF> <LPAR> Expression() <RPAR> Statement() <ELSE> Statement()
	| <WHILE> <LPAR> Expression() <RPAR> Statement()
	| LOOKAHEAD(2) Expression() <SEMICOLON>
	| <IDENTIFIER> ( <EQUAL> | <LSQUAREBRACKET> Expression() <RSQUAREBRACKET> <EQUAL> ) Expression() <SEMICOLON>
}

void Expression():{}
{
    <INTEGER> NewExpression()
    | <TRUE> NewExpression()
    | <FALSE> NewExpression()
    | <IDENTIFIER> NewExpression()
    | <THIS> NewExpression() 
    | <NEW> ( <INT> <LSQUAREBRACKET> Expression() <RSQUAREBRACKET> | Expression() ) NewExpression()
    | <NOT> Expression() NewExpression()
	| <LPAR> Expression() NewExpression()
}

void NewExpression():{}
{	
	SubExpression() Expression() NewExpression()
  	| <LSQUAREBRACKET> Expression() <RSQUAREBRACKET> NewExpression()
  	| <DOT> ( <LENGTH> | <IDENTIFIER> AuxExpression() ) NewExpression()
	| {}
}

/* ----------- -----------*/
void SubExpression() : {}
{
	<AND>
	| <MINOR>
	| <ADD>
	| <SUB>
	| <MUL>
	| <DIV>

}

void AuxExpression() : {}
{
  <LPAR>
    (
      Expression()
      (<COLON> Expression())*
    )?
  <RPAR>
}




