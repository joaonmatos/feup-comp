options {
  LOOKAHEAD = 1;
}


PARSER_BEGIN(Parser)

public class Parser {

    static int errors = 0;

}

PARSER_END(Parser)


//characters to ignore/skip
SKIP: {
  	  " " 
  	| "\r"	//move the cursor at start of current line 
  	| "\t"	//tab
  	| "\n"	//newline
  	| < "/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/" >  /*multiline comment*/
  	| < "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> //inline comment
}

TOKEN: {
    < INTEGER : (["0" - "9"])+ >
    | < STATIC: "static" >
    | < INT: "int" >
    | < BOOLEAN: "boolean" >
    | < STRING: "string" >
    | < SEMICOLON: ";" >
    | < COLON: "," >
    | < DOT: "." >
    | < TRUE: "true" >
    | < FALSE: "false" >
    | < NEW: "new" >
    | < THIS: "this" >
    | < LBRACKET: "{" >
    | < RBRACKET: "}" >
    | < LSQUAREBRACKET: "[" >
    | < RSQUAREBRACKET: "]" >
    | < LPAR: "(" >
    | < RPAR: ")" >
    | < PUBLIC: "public" >
    | < VOID: "void" >
    | < MAIN: "main" >
    | < RETURN: "return" >
    | < EXTENDS: "extends" >
    | < IMPORT: "import" >
    | < CLASS: "class" >
    | < WHILE: "while" >
    | < IF: "if" >
    | < ELSE: "else" >
    | < EQUAL: "=" >
    | < ADD: "+" >
    | < SUB: "-" >
    | < MUL: "*" >
    | < DIV: "/" >
    | < NOT: "!" >
    | < MINOR: "<" >
    | < AND: "&&" >
    | < LENGTH: "length" >
    | < STRINGARRAY: "String[]" >
    | < IDENTIFIER: ["$","a"-"z", "A"-"Z", "_"](["_", "a"-"z", "A"-"Z", "0"-"9"])* >
}


//DECLARATIONS

SimpleNode Program() : { Parser.errors = 0; }
{
    try
    {
        Imports() ClassDeclaration() <EOF> { return jjtThis; }
    } 
    catch (ParseException e)
    {
        System.out.println(e.toString());
        throw e;
    }
}


//Implemented following teachers examples (Lazysort.jmm)
// Can be one of following formats:
// import Class;
// import [static] Class.method(type1, type2, ...) type;

void Imports() #void: {}
{
  	(ImportDeclaration())*
}

void ImportDeclaration() #void: {}
{
  	<IMPORT> ( StaticImport() | NonStaticImport() ) <SEMICOLON>
}

void StaticImport(): {}
{
  	<STATIC> <IDENTIFIER> MethodImport()
}

void NonStaticImport() : {}
{
  	<IDENTIFIER> (MethodImport())?
}

void MethodImport() : {}
{
  	<DOT> <IDENTIFIER> <LPAR> (Type() | (<VOID> #VoidType))? (<COLON> Type())* <RPAR> (Type() | (<VOID> #VoidType)) #Ret
}

void ArgTypes(): {}
{
    <VOID> #VoidType
    | Type() (<COLON> Type())*
}

void ClassDeclaration() : {}
{
  	<CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER>)?
  	<LBRACKET>
  	  	(VarDeclaration())*
  	  	(MethodDeclaration())*
  	<RBRACKET>
}

void VarDeclaration() : {}
{
  	Type() TerminalId() <SEMICOLON> #VARDECLARATION
}


void MethodDeclaration() : {}
{ 
  	<PUBLIC>
        (
            Type() <IDENTIFIER> <LPAR> ( Type() <IDENTIFIER> ( <COLON> Type() <IDENTIFIER> )* )? <RPAR> <LBRACKET>
            (LOOKAHEAD(2) VarDeclaration())*
            (Statement())*
            <RETURN> Expression() <SEMICOLON>
        |
            <STATIC> <VOID> <MAIN> <LPAR> ( <STRINGARRAY> <IDENTIFIER> )? <RPAR> <LBRACKET>
            (LOOKAHEAD(2) VarDeclaration())*
            (Statement())*
        )
  	<RBRACKET>
}
 
void Type() : {}
{
    <INT> (
        <LSQUAREBRACKET> <RSQUAREBRACKET> #IntArrayType
        | {}  #IntType
    )
    | <BOOLEAN> #Bool
    | TerminalId()
}

void WhileCondition() #void: {}
{
    try
    {
        <LPAR> Expression() <RPAR>
    }
    catch (ParseException e)
    {
        Parser.errors += 1;
        String expectedTokens = new String(" ");
        for (int i = 0; i < e.expectedTokenSequences.length; i++) {
            for (int j = 0; j < e.expectedTokenSequences[i].length; j++) {
                if (i != 0) expectedTokens += ", ";
                expectedTokens += e.tokenImage[e.expectedTokenSequences[i][j]];
            }
        }

        System.out.println(
            "Error in line " + e.currentToken.next.beginLine + 
            ", column " + e.currentToken.next.beginColumn +
            ": found \"" + e.currentToken.next + "\"" +
            " but was expecting" + expectedTokens + ".");

        if (Parser.errors >= 10) {
            System.out.println("Encountered too many parsing errors. Exiting now.");
            System.exit(1);
        }
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != LBRACKET);
    }
}

void BinaryOperator() #void: {}
{
    <MINOR> #LessThan
    | <AND> #And
    | <ADD> #Add
    | <SUB> #Sub
    | <MUL> #Mul
    | <DIV> #Div
}

void Statement() #void: {}
{
    <WHILE> WhileCondition() Statement() #While
    | <IF> <LPAR> Expression() <RPAR> Statement() <ELSE> Statement() #IfElse
    | <LBRACKET> Block() <RBRACKET>
    | TerminalId() (
        DotExpression() DetachedExpansion()
        | <EQUAL> Expression() #Assignment
        | SquareBracketExpression() (
            <EQUAL> Expression() #Assignment
            | DetachedExpansion()
        )
    ) <SEMICOLON>
    | TerminalNonId() DetachedExpansion() <SEMICOLON>

}

void Block(): {}
{
    (Statement())*
}

void DetachedExpansion() : {}
{
    (UnaryExpression2() #DetachedUnaryOp)? (BinaryOperator() Expression() #DetachedBinaryOp)?
}

void Expression() #void: {}
{
    LessThanExpression() (<AND> Expression() #And)?
}

void LessThanExpression() #void: {}
{
    SumExpression() (<MINOR> SumExpression() #LessThan)?
}

void SumExpression() #void: {}
{
    ProductExpression() (
        <ADD> SumExpression() #Add
        | <SUB> SumExpression() #Sub
    )?
}

void ProductExpression() #void: {}
{
    NegationExpression() (
        <MUL> ProductExpression() #Mul
        | <DIV> ProductExpression() #Div
    )?
}

void NegationExpression() #void: {}
{
    <NOT> UnaryExpression1() #Not
    | UnaryExpression1()
}

void UnaryExpression1() #void: {}
{
    Terminal() (UnaryExpression2())?
}

void UnaryExpression2() #void: {}
{
    (
        DotExpression()
        | SquareBracketExpression()
    ) (UnaryExpression2())?
}

void DotExpression() #void: {}
{
    <DOT> (
        <LENGTH> #Len
        | Method() #MethodInvocation
    )
}

void SquareBracketExpression() #void: {}
{
    <LSQUAREBRACKET> Expression() <RSQUAREBRACKET> #Arr
}

void Terminal() #void: {}
{
    TerminalId()
    | TerminalNonId()
}

void TerminalNonId() #void: {Token t;}
{
    <TRUE> #True
    | <FALSE> #False
    | <THIS> #This
    | <NEW> (
        <INT> <LSQUAREBRACKET> Expression() <RSQUAREBRACKET> #NewIntArray
        | TerminalId() <LPAR> <RPAR> #NewObject
    )
    | t=<INTEGER> {jjtThis.value = Integer.valueOf(t.image);} #Int
    | <LPAR> Expression() <RPAR>
}

void Method(): {}
{
    TerminalId() <LPAR> ArgList() <RPAR>
}

void TerminalId() #void: {Token t;}
{
    t=<IDENTIFIER> {jjtThis.value = t.image;} #Id
}

void ArgList() : {}
{
    (Expression() (<COLON> Expression())*)?
}
