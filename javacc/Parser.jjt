options {

  LOOKAHEAD = 1;

}


PARSER_BEGIN(Parser)

public class Parser{

   public static void main(String args[]) throws ParseException {

   }

}

PARSER_END(Parser)


//characters to ignore/skip
SKIP: {
    " " 
  | "\r" 
  | "\t" 
  | "\n" 
  | <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> 
}

TOKEN: {

    < INTEGER : (["0" - "9"])+ >
  | < IDENTIFIER: ["a"-"z", "A"-"Z"](["_", "a"-"z", "A"-"Z", "0"-"9"])* >
  | < INT: "int" >
  | < BOOLEAN: "boolean" >
  | < STRING: "string" >
  | < SEMICOLON: ";" >
  | < COLON: "," >
  | < DOT: "." >
  | < TRUE: "true" >
  | < FALSE: "false" >
  | < NEW: "new" >
  | < THIS: "this" >
  | < LBRACKET: "{" >
  | < RBRACKET: "}" >
  | < LSQUAREBRACKET: "[" >
  | < RSQUAREBRACKET: "]" >
  | < LPAR: "(" >
  | < RPAR: ")" >
  | < PUBLIC: "public" >
  | < STATIC: "static" >
  | < VOID: "void" >
  | < MAIN: "main" >
  | < RETURN: "return" >
  | < EXTENDS: "extends" >
  | < IMPORT: "import" >
  | < CLASS: "class" >
  | < WHILE: "while" >
  | < IF: "if" >
  | < ELSE: "else" >
  | < EQUAL: "=" >
  | < ADD: "+" >
  | < SUB: "-" >
  | < MUL: "*" >
  | < DIV: "/" >
  | < NOT: "!" >
  | < MINOR: "<" >
  | < AND: "&&" >
  | < LENGTH: "length" >
  | < STRINGARRAY: "String[]" >
  
}


//DECLARATIONS

void Program() : {}
{
  ImportDeclaration() ClassDeclaration() <EOF>
}


//Implemented following teachers examples (Lazysort.jmm)

void ImportDeclaration() : {}
{
  (
    
    <IMPORT> (<STATIC>)? <IDENTIFIER>
    (AuxImport())?
    (Type())?
    <SEMICOLON>
  
  )*
}

void AuxImport():{}
{
  <DOT> <IDENTIFIER> <LPAR> Type() (<COLON> Type())* <RPAR>
}

void ClassDeclaration() : {}
{
  <CLASS> <IDENTIFIER> 
  (<EXTENDS> <IDENTIFIER>)?
  <LBRACKET>
    (VarDeclaration())*
    (MethodDeclaration())*
  <RBRACKET>
}

void VarDeclaration() : {}
{
  Type() <IDENTIFIER> <SEMICOLON>
}


void MethodDeclaration() : {}
{

  <PUBLIC> Type() <IDENTIFIER> <LPAR> (  Type() <IDENTIFIER> ( <COLON> Type() <IDENTIFIER> )*  )? <RPAR> <LBRACKET>
    (VarDeclaration())*
    (Statement())*
    <RETURN> Expression() <SEMICOLON>
  <RBRACKET>
  | <PUBLIC> <STATIC> <VOID> <MAIN> <RPAR> ( <STRINGARRAY> <IDENTIFIER> )?<LPAR><LBRACKET>
    (VarDeclaration())*
    (Statement())*
  <RBRACKET>

}

void Type(): {}
{

    <INTEGER> (<LSQUAREBRACKET> <RSQUAREBRACKET>)? //int or int[]
  | <BOOLEAN>
  | <IDENTIFIER>

}

void Statement(): {}
{
  
    <LBRACKET> (Statement())* <RBRACKET>
  | <IF> <LPAR> Expression() <RPAR> Statement() <ELSE> Statement()
  | <WHILE> <LPAR> Expression() <RPAR> Statement()
  | Expression() <SEMICOLON>
  | <IDENTIFIER> <EQUAL> Expression() <SEMICOLON>
  | <IDENTIFIER> <LSQUAREBRACKET> Expression() <RSQUAREBRACKET> <EQUAL> Expression() <SEMICOLON>

}

void Expression():{}
{
    Expression() SubExpression() Expression()
  | Expression() <LSQUAREBRACKET> Expression() <RSQUAREBRACKET>
  | Expression() <DOT> <LENGTH>
  | Expression() <DOT> <IDENTIFIER> AuxExpression()
  | <INTEGER>
  | <TRUE>
  | <FALSE>
  | <IDENTIFIER>
  | <THIS>
  | <NEW> <INT> <LSQUAREBRACKET> Expression() <RSQUAREBRACKET>
  | <NEW> Expression()
  | <NOT> Expression()
  | <LPAR> Expression() <RPAR>

}

void SubExpression() : {}
{
    <AND>
  | <MINOR>
  | <ADD>
  | <SUB>
  | <MUL>
  | <DIV>

}

void AuxExpression() : {}
{
  
  <LPAR>
    (
      Expression()
      (<COLON> Expression())*
    )?
  <RPAR>

}




