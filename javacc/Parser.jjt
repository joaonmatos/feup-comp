options {

  LOOKAHEAD = 1;

}


PARSER_BEGIN(Parser)

public class Parser{

   public static void main(String args[]) throws ParseException {

   }

}

PARSER_END(Parser)


//characters to ignore/skip
SKIP: {
    " " 
  | "\r" 
  | "\t" 
  | "\n" 
  | <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> 
}

TOKEN: {

    < INTEGER : (["0" - "9"])+ >
    | < INT: "int" >
    | < BOOLEAN: "boolean" >
    | < STRING: "string" >
    | < SEMICOLON: ";" >
    | < COLON: "," >
    | < DOT: "." >
    | < TRUE: "true" >
    | < FALSE: "false" >
    | < NEW: "new" >
    | < THIS: "this" >
    | < LBRACKET: "{" >
    | < RBRACKET: "}" >
    | < LSQUAREBRACKET: "[" >
    | < RSQUAREBRACKET: "]" >
    | < LPAR: "(" >
    | < RPAR: ")" >
    | < PUBLIC: "public" >
    | < STATIC: "static" >
    | < VOID: "void" >
    | < MAIN: "main" >
    | < RETURN: "return" >
    | < EXTENDS: "extends" >
    | < IMPORT: "import" >
    | < CLASS: "class" >
    | < WHILE: "while" >
    | < IF: "if" >
    | < ELSE: "else" >
    | < EQUAL: "=" >
    | < ADD: "+" >
    | < SUB: "-" >
    | < MUL: "*" >
    | < DIV: "/" >
    | < NOT: "!" >
    | < MINOR: "<" >
    | < AND: "&&" >
    | < LENGTH: "length" >
    | < STRINGARRAY: "String[]" >
    | < IDENTIFIER: ["a"-"z", "A"-"Z", "_"](["_", "a"-"z", "A"-"Z", "0"-"9"])* >
}


//DECLARATIONS

void Program() : {}
{
  Imports() ClassDeclaration() <EOF>
}


//Implemented following teachers examples (Lazysort.jmm)
// Can be one of following formats:
// import Class;
// import [static] Class.method(type1, type2, ...) type;

void Imports() : {}
{
  (
    ImportDeclaration()
  )*
}

void ImportDeclaration() : {}
{
  <IMPORT> (
    StaticImport()
    | NonStaticImport()
  )
  <SEMICOLON>
}

void StaticImport(): {
  <STATIC>
  <IDENTIFIER> // class identifier
  MethodImport()
}

void NonStaticImport(): {
  <IDENTIFIER> // class identifier
  (MethodImport())?
}

void MethodImport():{}
{
  <DOT> <IDENTIFIER> <LPAR> Type() (<COLON> Type())* <RPAR> Type()
}

void ClassDeclaration() : {}
{
  <CLASS> <IDENTIFIER> 
  (<EXTENDS> <IDENTIFIER>)?
  <LBRACKET>
    (VarDeclaration())*
    (MethodDeclaration())*
  <RBRACKET>
}

void VarDeclaration() : {}
{
  Type() <IDENTIFIER> <SEMICOLON>
}


void MethodDeclaration() : {}
{ // <a> (<b> | <c>)

  <PUBLIC> (
    Type() <IDENTIFIER> <LPAR> ( Type() <IDENTIFIER> ( <COLON> Type() <IDENTIFIER> )* )? <RPAR> <LBRACKET>
    (LOOKAHEAD(2) VarDeclaration())*
    (Statement())*
    <RETURN> Expression() <SEMICOLON>
    | <STATIC> <VOID> <MAIN> <LPAR> ( <STRINGARRAY> <IDENTIFIER> )? <RPAR> <LBRACKET>
    (LOOKAHEAD(2) VarDeclaration())*
    (Statement())*)
  <RBRACKET>

}
 
void Type(): {}
{
      <INTEGER> (<LSQUAREBRACKET> <RSQUAREBRACKET>)? //int or int[]
      | <BOOLEAN>
      | <IDENTIFIER>
}

void Statement(): {}
{
    <LBRACKET> (Statement())* <RBRACKET>
    | <IF> <LPAR> Expression() <RPAR> Statement() <ELSE> Statement()
    | <WHILE> <LPAR> Expression() <RPAR> Statement()
    | LOOKAHEAD(2) Expression() <SEMICOLON>
    | <IDENTIFIER> ( <EQUAL> | <LSQUAREBRACKET> Expression() <RSQUAREBRACKET> <EQUAL> ) Expression() <SEMICOLON>
}

void Expression():{}
{
    <INTEGER> NewExpression()
    | <TRUE> NewExpression()
    | <FALSE> NewExpression()
    | <IDENTIFIER> NewExpression()
    | <THIS> NewExpression() 
    | <NEW> ( <INT> <LSQUAREBRACKET> Expression() <RSQUAREBRACKET> | Expression() ) NewExpression()
    | <NOT> Expression() NewExpression()
    | <LPAR> Expression() NewExpression()
}

void NewExpression():{}
{	
    SubExpression() Expression() NewExpression()
      | <LSQUAREBRACKET> Expression() <RSQUAREBRACKET> NewExpression()
      | <DOT> ( <LENGTH> | <IDENTIFIER> AuxExpression() ) NewExpression()
    | {}
}

/* ----------- -----------*/
void SubExpression() : {}
{
    <AND>
    | <MINOR>
    | <ADD>
    | <SUB>
    | <MUL>
    | <DIV>

}

void AuxExpression() : {}
{
  <LPAR> ( Expression() ( <COLON> Expression() )* )? <RPAR>
}




