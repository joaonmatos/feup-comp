options {
  LOOKAHEAD = 1;
}


PARSER_BEGIN(Parser)

public class Parser {

    static int errors = 0;

}

PARSER_END(Parser)


//characters to ignore/skip
SKIP: {
  	  " " 
  	| "\r"	//move the cursor at start of current line 
  	| "\t"	//tab
  	| "\n"	//newline
  	| < "/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/" >  /*multiline comment*/
  	| < "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> //inline comment
}

TOKEN: {
    < INTEGER : (["0" - "9"])+ >
    | < STATIC: "static" >
    | < INT: "int" >
    | < BOOLEAN: "boolean" >
    | < STRING: "string" >
    | < SEMICOLON: ";" >
    | < COLON: "," >
    | < DOT: "." >
    | < TRUE: "true" >
    | < FALSE: "false" >
    | < NEW: "new" >
    | < THIS: "this" >
    | < LBRACKET: "{" >
    | < RBRACKET: "}" >
    | < LSQUAREBRACKET: "[" >
    | < RSQUAREBRACKET: "]" >
    | < LPAR: "(" >
    | < RPAR: ")" >
    | < PUBLIC: "public" >
    | < VOID: "void" >
    | < MAIN: "main" >
    | < RETURN: "return" >
    | < EXTENDS: "extends" >
    | < IMPORT: "import" >
    | < CLASS: "class" >
    | < WHILE: "while" >
    | < IF: "if" >
    | < ELSE: "else" >
    | < EQUAL: "=" >
    | < ADD: "+" >
    | < SUB: "-" >
    | < MUL: "*" >
    | < DIV: "/" >
    | < NOT: "!" >
    | < MINOR: "<" >
    | < AND: "&&" >
    | < LENGTH: "length" >
    | < STRINGARRAY: "String[]" >
    | < IDENTIFIER: ["$","a"-"z", "A"-"Z", "_"](["_", "a"-"z", "A"-"Z", "0"-"9"])* >
}


//DECLARATIONS

SimpleNode Program() : { Parser.errors = 0; }
{
    try
    {
        Imports() ClassDeclaration() <EOF> { return jjtThis; }
    } 
    catch (ParseException e)
    {
        System.out.println(e.toString());
        throw e;
    }
}


//Implemented following teachers examples (Lazysort.jmm)
// Can be one of following formats:
// import Class;
// import [static] Class.method(type1, type2, ...) type;

void Imports() #void: {}
{
  	(ImportDeclaration())*
}

void ImportDeclaration() #void: {}
{
  	<IMPORT> ( StaticImport() | NonStaticImport() ) <SEMICOLON>
}

void StaticImport(): {}
{
    <STATIC> TerminalId() MethodImport()
}

void NonStaticImport() : {}
{
  	TerminalId() (MethodImport())?
}

void MethodImport() : {}
{
  	<DOT> TerminalId() <LPAR> ImportParamList() <RPAR> Return()
}

void ImportParamList() #ParamList: {}
{
    (Type() | <VOID>)? (<COLON> Type())*
}

void Return() : {}
{
    (Type() | <VOID>)
}

void ClassDeclaration() #Class : {Token t;}
{
  	<CLASS> t = <IDENTIFIER> {jjtThis.value = t.image;} (<EXTENDS> <IDENTIFIER>)?
  	<LBRACKET>
  	  	(VarDeclaration() <SEMICOLON>)*
  	  	(MethodDeclaration())*
  	<RBRACKET>
}

void VarDeclaration() : {}
{
  	Type() TerminalId()
}


void MethodDeclaration() #Method : {Token t;}
{ 
  	<PUBLIC>
        (
            Type() t = <IDENTIFIER> {jjtThis.value = t.image;} <LPAR> MethodParamList() <RPAR> <LBRACKET>
            (
                (LOOKAHEAD(2) VarDeclaration() <SEMICOLON>)*
                (Statement())*
                MethodReturn()
            ) #Body
        |
            <STATIC> <VOID> t = <MAIN> {jjtThis.value = t.image;} <LPAR> MainParamList() <RPAR> <LBRACKET>
            (
                (LOOKAHEAD(2) VarDeclaration() <SEMICOLON>)*
                (Statement())*
            ) #Body
        )
  	<RBRACKET>
}

void MethodParamList() #ParamList: {}
{
    ( VarDeclaration() ( <COLON> VarDeclaration() )* )?
}

void MethodReturn() #Return: {}
{
    <RETURN> Expression() <SEMICOLON>
}

void MainParamList() #ParamList: {}
{
    (<STRINGARRAY> <IDENTIFIER>)?
}
 
void Type() : {Token t;}
{
    t = <INT> {jjtThis.value = t.image;} (<LSQUAREBRACKET> <RSQUAREBRACKET>)?
    | t = <BOOLEAN> {jjtThis.value = t.image;}
    | TerminalId()
}

void WhileCondition() #Condition: {}
{
    try
    {
        <LPAR> Expression() <RPAR>
    }
    catch (ParseException e)
    {
        Parser.errors += 1;
        String expectedTokens = new String(" ");
        for (int i = 0; i < e.expectedTokenSequences.length; i++) {
            for (int j = 0; j < e.expectedTokenSequences[i].length; j++) {
                if (i != 0) expectedTokens += ", ";
                expectedTokens += e.tokenImage[e.expectedTokenSequences[i][j]];
            }
        }

        System.out.println(
            "Error in line " + e.currentToken.next.beginLine + 
            ", column " + e.currentToken.next.beginColumn +
            ": found \"" + e.currentToken.next + "\"" +
            " but was expecting" + expectedTokens + ".");

        if (Parser.errors >= 10) {
            System.out.println("Encountered too many parsing errors. Exiting now.");
            System.exit(1);
        }
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != LBRACKET);
    }
}

void BinaryOperator() #void: {}
{
    <MINOR> #LessThan
    | <AND> #And
    | <ADD> #Add
    | <SUB> #Sub
    | <MUL> #Mul
    | <DIV> #Div
}

void Statement() #void: {}
{
    WhileLoop()
    | IfStatement()
    | Scope()
    | TerminalId() (
            DotExpression() DetachedExpansion()
            | Assignment()
            | SquareBracketExpression() ( Assignment() | DetachedExpansion() )
            | BinaryOperator() Expression() #DetachedBinaryOp(3)
        ) <SEMICOLON>
    | TerminalNonId() DetachedExpansion() <SEMICOLON>

}

void Assignment() #Assignment(2) : {}
{
    <EQUAL> Expression()
}

void WhileLoop() #While : {}
{
    <WHILE> WhileCondition() Statement()
}

void IfStatement() : {}
{
    <IF> <LPAR> Expression() #Condition <RPAR> Statement() <ELSE> Statement()
}

void Scope(): {}
{
    <LBRACKET> (Statement())* <RBRACKET>
}

void DetachedExpansion() #void: {}
{
    (UnaryExpression2() #DetachedUnaryOp(2))? (BinaryOperator() Expression() #DetachedBinaryOp(3))?
}

void Expression() #void: {}
{
    LessThanExpression() (<AND> Expression() #And(2))?
}

void LessThanExpression() #void: {}
{
    SumExpression() (<MINOR> SumExpression() #LessThan(2))?
}

void SumExpression() #void: {}
{
    ProductExpression() (
        <ADD> SumExpression() #Add(2)
        | <SUB> SumExpression() #Sub(2)
    )?
}

void ProductExpression() #void: {}
{
    NegationExpression() (
        <MUL> ProductExpression() #Mul(2)
        | <DIV> ProductExpression() #Div(2)
    )?
}

void NegationExpression() #void : {}
{
    <NOT> UnaryExpression1() #Not(1)
    | UnaryExpression1()
}

void UnaryExpression1() #void: {}
{
    Terminal() (UnaryExpression2())?
}

void UnaryExpression2() #void: {}
{
    (
        DotExpression()
        | SquareBracketExpression()
    ) (UnaryExpression2())?
}

void DotExpression() #void: {}
{
    <DOT> (
        <LENGTH> #Length(1)
        | MethodInvocation() #MethodInvocation(2)
    )
}

void SquareBracketExpression() #void: {}
{
    <LSQUAREBRACKET> Expression() <RSQUAREBRACKET> #Arr(2)
}

void Terminal() #void: {}
{
    TerminalId()
    | TerminalNonId()
}

void TerminalNonId() #void: {Token t;}
{
    t = <TRUE> {jjtThis.value = Boolean.valueOf(t.image);} #Boolean
    | t = <FALSE> {jjtThis.value = Boolean.valueOf(t.image);} #Boolean
    | <THIS> #This
    | <NEW> (
        <INT> <LSQUAREBRACKET> Expression() <RSQUAREBRACKET> #NewIntArray(1)
        | TerminalId() <LPAR> <RPAR> #NewObject(1)
    )
    | t = <INTEGER> {jjtThis.value = Integer.valueOf(t.image);} #Integer
    | <LPAR> Expression() <RPAR>
}

void TerminalId() #Identifier: {Token t;}
{
    t = <IDENTIFIER> {jjtThis.value = t.image;}
}

void MethodInvocation() #void: {}
{
    TerminalId() <LPAR> ArgList() <RPAR> 
}

void ArgList(): {}
{
    (Expression() (<COLON> Expression())*)?
}
