options {
  LOOKAHEAD = 1;
}


PARSER_BEGIN(Parser)

public class Parser {

    static int errors = 0;

}

PARSER_END(Parser)


//characters to ignore/skip
SKIP: {
  	  " " 
  	| "\r"	//move the cursor at start of current line 
  	| "\t"	//tab
  	| "\n"	//newline
  	| < "/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/" >  /*multiline comment*/
  	| < "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")> //inline comment
}

TOKEN: {
    < INTEGER : (["0" - "9"])+ >
    | < STATIC: "static" >
    | < INT: "int" >
    | < BOOLEAN: "boolean" >
    | < STRING: "string" >
    | < SEMICOLON: ";" >
    | < COLON: "," >
    | < DOT: "." >
    | < TRUE: "true" >
    | < FALSE: "false" >
    | < NEW: "new" >
    | < THIS: "this" >
    | < LBRACKET: "{" >
    | < RBRACKET: "}" >
    | < LSQUAREBRACKET: "[" >
    | < RSQUAREBRACKET: "]" >
    | < LPAR: "(" >
    | < RPAR: ")" >
    | < PUBLIC: "public" >
    | < VOID: "void" >
    | < MAIN: "main" >
    | < RETURN: "return" >
    | < EXTENDS: "extends" >
    | < IMPORT: "import" >
    | < CLASS: "class" >
    | < WHILE: "while" >
    | < IF: "if" >
    | < ELSE: "else" >
    | < EQUAL: "=" >
    | < ADD: "+" >
    | < SUB: "-" >
    | < MUL: "*" >
    | < DIV: "/" >
    | < NOT: "!" >
    | < MINOR: "<" >
    | < AND: "&&" >
    | < LENGTH: "length" >
    | < STRINGARRAY: "String[]" >
    | < IDENTIFIER: ["$","a"-"z", "A"-"Z", "_"](["_", "a"-"z", "A"-"Z", "0"-"9"])* >
}


//DECLARATIONS

void Program() : { Parser.errors = 0; }
{
  	Imports() ClassDeclaration() <EOF>
}


//Implemented following teachers examples (Lazysort.jmm)
// Can be one of following formats:
// import Class;
// import [static] Class.method(type1, type2, ...) type;

void Imports() : {}
{
  	(ImportDeclaration())*
}

void ImportDeclaration() : {}
{
  	<IMPORT> ( StaticImport() | NonStaticImport() ) <SEMICOLON>
}

void StaticImport() : {}
{
  	<STATIC> <IDENTIFIER> MethodImport()
}

void NonStaticImport() : {}
{
  	<IDENTIFIER> (MethodImport())?
}

void MethodImport() : {}
{
  	<DOT> <IDENTIFIER> <LPAR> (Type() | <VOID>)? (<COLON> Type())* <RPAR> (Type() | <VOID>)
}

void ClassDeclaration() : {}
{
  	<CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER>)?
  	<LBRACKET>
  	  	(VarDeclaration())*
  	  	(MethodDeclaration())*
  	<RBRACKET>
}

void VarDeclaration() : {}
{
  	Type() <IDENTIFIER> <SEMICOLON>
}


void MethodDeclaration() : {}
{ 
  	<PUBLIC>
        (
            Type() <IDENTIFIER> <LPAR> ( Type() <IDENTIFIER> ( <COLON> Type() <IDENTIFIER> )* )? <RPAR> <LBRACKET>
            (LOOKAHEAD(2) VarDeclaration())*
            (Statement())*
            <RETURN> Expression() <SEMICOLON>
        |
            <STATIC> <VOID> <MAIN> <LPAR> ( <STRINGARRAY> <IDENTIFIER> )? <RPAR> <LBRACKET>
            (LOOKAHEAD(2) VarDeclaration())*
            (Statement())*
        )
  	<RBRACKET>
}
 
void Type() : {}
{
    <INT> (<LSQUAREBRACKET> <RSQUAREBRACKET>)? //int or int[]
    | <BOOLEAN>
    | <IDENTIFIER>
}

void WhileCondition() : {}
{
    try
    {
        <LPAR> Expression() <RPAR>
    }
    catch (ParseException e)
    {
        System.out.println(e.toString());
        if (Parser.errors >= 10) {
            System.out.println("Encountered too many parsing errors. Exiting now.");
            System.exit(1);
        }
        Parser.errors += 1;
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != LBRACKET);
    }
}

void AuxExpression() : {}
{
  	<LPAR> ( Expression() ( <COLON> Expression() )* )? <RPAR>
}

void Statement() : {}
{
    <LBRACKET> (Statement())* <RBRACKET>
    | <IF> <LPAR> Expression() <RPAR> Statement() <ELSE> Statement()
    | <WHILE> WhileCondition() Statement()
    | <IDENTIFIER> 
        (
            NewExpression2()
            | <LSQUAREBRACKET> Expression() <RSQUAREBRACKET> (Assignment())?
            | Assignment()
        )? <SEMICOLON>
    | Expression2() <SEMICOLON>
}

void Assignment() : {}
{
    <EQUAL> Expression()
}

void Expression() : {}
{
    <IDENTIFIER> NewExpression()
    | Expression2()
}

void Expression2() : {}
{
    <INTEGER> NewExpression()
    | <TRUE> NewExpression()
    | <FALSE> NewExpression()
    | <THIS> NewExpression()
    | <NEW> (<INT> <LSQUAREBRACKET> Expression() <RSQUAREBRACKET> | <IDENTIFIER> <LPAR> <RPAR>) NewExpression()
    | <NOT> Expression() NewExpression()
    | <LPAR> Expression() <RPAR> NewExpression()
}

void NewExpression() : {}
{
    NewExpression2()
    | <LSQUAREBRACKET> Expression() <RSQUAREBRACKET> NewExpression()
    | {}
}

void NewExpression2() : {}
{
    (<AND> | <MINOR> | <ADD> | <SUB> | <MUL> | <DIV>) Expression() NewExpression()
    | <DOT> (<LENGTH> | <IDENTIFIER> AuxExpression()) NewExpression()
}



// void Statement() : {}
// {
//     <LBRACKET> (Statement())* <RBRACKET>
//     | <IF> <LPAR> Expression() <RPAR> Statement() <ELSE> Statement()
//     | <WHILE> WhileCondition() Statement()
//     | StatementInitialIdentifier()
// }

// void StatementInitialIdentifier() : {}
// {
//     Expression() (<EQUAL> Expression())? <SEMICOLON>
// }

// void Expression() : {}
// {
//     <IDENTIFIER> NewExpression()
//     | <INTEGER> NewExpression()
//     | <TRUE> NewExpression()
//     | <FALSE> NewExpression()
//     | <THIS> NewExpression() 
//     | <NEW> ( (<INT> <LSQUAREBRACKET> Expression() <RSQUAREBRACKET>) | (<IDENTIFIER> <LPAR> <RPAR>) ) NewExpression()
//     | <NOT> Expression() NewExpression()
//     | <LPAR> Expression() <RPAR> NewExpression()
// }

// void NewExpression() : {}
// {	
//     BinaryOperator() Expression() NewExpression()
//     | <LSQUAREBRACKET> Expression() <RSQUAREBRACKET> NewExpression()
//     | <DOT> ( <LENGTH> | <IDENTIFIER> AuxExpression() ) NewExpression()
//     | {}
// }

// /* ----------- -----------*/
// void BinaryOperator() : {}
// {
//     <AND>
//     | <MINOR>
//     | <ADD>
//     | <SUB>
//     | <MUL>
//     | <DIV>
// }